# DocumentDbExtensions Methods
 

The <a href="2e7c24fb-f7c9-2314-1ff8-386e1be4f471">DocumentDbExtensions</a> type exposes the following members.


## Methods
&nbsp;<table><tr><th></th><th>Name</th><th>Description</th></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="79556f34-98e8-b97d-1910-1b424f909716">CreateQueryForPagingContinuationOnly(TElement)</a></td><td>
This method will create an IQuerable which allows you to call GetNextPage(continuationToken) even after having "lost" the original IQueryable instance, as long as you still have the continuationToken. If the original IQueryable created via InterceptQuery() is still around, you can simply call GetNextPage() with no parameters instead, as the continuations will be tracked internally to that instance.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="00b74519-e9cb-2647-86c7-3a0e4c93bfe5">DefaultEnumerationExceptionHandlerImplementation</a></td><td>
The implementation of the default EnumerationExceptionHandler logic, this is assigned to "DefaultEnumerationExceptionHandler" by default. This implementation will cause the caller to re-throw the exception from its original context which will be propagated back out to the code which is enumerating the results.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="ef7a74e5-7b95-9d73-dacf-3c8d48ee5e27">DefaultFeedResponseHandlerImplementation</a></td><td>
The implementation of the default FeedResponseHandler logic, this is assigned to "DefaultFeedResponseHandler" by default. This implementation does nothing.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="b1a3c37c-ee7b-1b29-c03b-c5a2f9c7a5aa">DefaultQueryExecutionHandlerImplementation</a></td><td>
The implementation of the default QueryExecutionHandler logic, this is assigned to "DefaultQueryExecutionHandler" by default. This implementation does nothing and throws away the query string.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="05ab7160-30f1-f18e-6086-5707c495dd10">DefaultResourceResponseHandlerImplementation</a></td><td>
The implementation of the default ResourceResponseHandler logic, this is assigned to "DefaultResourceResponseHandler" by default. This implementation does nothing.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="893871d7-c207-507a-46c4-6e14fee8d9b5">DefaultShouldRetryLogicImplementation</a></td><td>
The implementation of the default ShouldRetry logic, this is assigned to "DefaultShouldRetry" by default.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="52b92d2f-e5f8-0ded-2e73-059ad967fbb4">ExecuteFeedWithContinuationAndRetry(R)(Func(String, FeedResponse(R)), EnumerationExceptionHandler, FeedResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client FeedResponse method for you while handling retriable errors such as "too many requests". The caller must explicitly wrap the async call they want to make in a lambda. This is so that WithRetry can execute the lambda in order to ask for the task multiple times instead of getting an instance created at WithRetry method invocation time. Because of an implementation detail of the DocumentDb Client, you'll need your lambda to take the continuation token and apply it to the feed options passed into the method you've wrapped in your lambda. Example: "ExecuteResultWithRetry((continuation) => { feedOptions.RequestContinuation = continuation; YourCallHere(arguments, will, be, closured, feedOptions));"</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="b296ffe9-ff52-37a6-0466-9ef016cf207e">ExecuteFeedWithContinuationAndRetry(R)(Func(String, Task(FeedResponse(R))), EnumerationExceptionHandler, FeedResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client FeedResponse method for you while handling retriable errors such as "too many requests". The caller must explicitly wrap the async call they want to make in a lambda. This is so that WithRetry can execute the lambda in order to ask for the task multiple times instead of getting an instance created at WithRetry method invocation time. Because of an implementation detail of the DocumentDb Client, you'll need your lambda to take the continuation token and apply it to the feed options passed into the method you've wrapped in your lambda. Example: "ExecuteResultWithRetry((continuation) => { feedOptions.RequestContinuation = continuation; YourCallHere(arguments, will, be, closured, feedOptions));"</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="0c280a92-5eda-fb0f-d1f4-6d27cc001134">ExecuteQueryWithContinuationAndRetry(TElement)</a></td><td>
This will execute a DocumentDB query in the form of an IQueryable (Linq form) and return the results. It handles paging, continuation tokens, and retriable errors such as "too many requests" for you, while aggregating all query results in-memory before returning. You don't need to use this if you have called InterceptQuery() on the IQueryable previously.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="9248b44c-990c-a1fe-a0d2-98a1b1703577">ExecuteQueryWithContinuationAndRetryAsync(TElement)</a></td><td>
This will execute a DocumentDB query in the form of an IQueryable (Linq form) and return the results. It handles paging, continuation tokens, and retriable errors such as "too many requests" for you, while aggregating all query results in-memory before returning. You don't need to use this if you have called InterceptQuery() on the IQueryable previously.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="9e9b4e65-0935-e4c4-b246-da5b04729207">ExecuteResultWithRetry(Action, ResourceResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client method for you while handling retriable errors such as "too many requests".</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="e38568a3-d423-c1b8-ffb8-3ce75a09ab44">ExecuteResultWithRetry(Func(Task), ResourceResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client method for you while handling retriable errors such as "too many requests". The caller must explicitly wrap the async call they want to make in a lambda. This is so that WithRetry can execute the lambda in order to ask for the task multiple times instead of getting an instance created at WithRetry method invocation time. Example: "ExecuteResultWithRetry(() => YourCallHere(arguments, will, be, closured));"</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="b0bee513-b965-b8df-9961-42ecf45bbfa4">ExecuteResultWithRetry(R)(Func(Task(R)), ResourceResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client method for you while handling retriable errors such as "too many requests". The caller must explicitly wrap the async call they want to make in a lambda. This is so that WithRetry can execute the lambda in order to ask for the task multiple times instead of getting an instance created at WithRetry method invocation time. Example: "ExecuteResultWithRetry(() => YourCallHere(arguments, will, be, closured));"</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="a5969eab-bec2-03d4-8141-b98dfb2d2a13">ExecuteResultWithRetry(R)(Func(R), ResourceResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client method for you while handling retriable errors such as "too many requests".</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="6dc8418c-1e6f-caa8-72c4-0847a8efcf26">ExecuteResultWithRetryAsync(Action, ResourceResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client method for you while handling retriable errors such as "too many requests".</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="8a1cd2b4-dd78-4c9f-37d7-42d40824c256">ExecuteResultWithRetryAsync(Func(Task), ResourceResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client method for you while handling retriable errors such as "too many requests". The caller must explicitly wrap the async call they want to make in a lambda. This is so that WithRetry can execute the lambda in order to ask for the task multiple times instead of getting an instance created at WithRetry method invocation time. Example: "ExecuteResultWithRetry(() => YourCallHere(arguments, will, be, closured));"</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="d16d9460-d6a5-7c6d-58e1-c36831975515">ExecuteResultWithRetryAsync(R)(Func(Task(R)), ResourceResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client method for you while handling retriable errors such as "too many requests". The caller must explicitly wrap the async call they want to make in a lambda. This is so that WithRetry can execute the lambda in order to ask for the task multiple times instead of getting an instance created at WithRetry method invocation time. Example: "ExecuteResultWithRetry(() => YourCallHere(arguments, will, be, closured));"</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="cc1155ea-b547-de6b-41b0-d8f0f5332f3e">ExecuteResultWithRetryAsync(R)(Func(R), ResourceResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client method for you while handling retriable errors such as "too many requests".</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="54069f50-2291-c86e-28a7-971413cfc5cb">InterceptQuery(TElement)</a></td><td>
To gain the advantage of the query translator (allows you to use things like DateTime and DateTimeOffset in queries) plus reliable execution, you must intercept the IQueryable returned by the DocumentDB Client by calling this method on it BEFORE you start adding things like ".Where(...)" or ".Select(...)" etc. Once the DocumentDB IQueryable is wrapped, you can use it just like any other standard IQueryable. It will translate (some) expressions that DocumentDB doesn't handle, and lazily enumerate with retries on each "page". You do not need to call any of the query execution methods in this class on it afterward, everything is automatic once the IQueryable has been intercepted.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="230f7f8d-7380-8ad2-f724-65a2a1d6ed0f">StreamFeedWithContinuationAndRetry(R)(Func(String, FeedResponse(R)), EnumerationExceptionHandler, FeedResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client FeedResponse method for you while handling retriable errors such as "too many requests". The caller must explicitly wrap the async call they want to make in a lambda. This is so that WithRetry can execute the lambda in order to ask for the task multiple times instead of getting an instance created at WithRetry method invocation time. Because of an implementation detail of the DocumentDb Client, you'll need your lambda to take the continuation token and apply it to the feed options passed into the method you've wrapped in your lambda. Example: "ExecuteResultWithRetry((continuation) => { feedOptions.RequestContinuation = continuation; YourCallHere(arguments, will, be, closured, feedOptions));"</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="238f4787-2b0b-1b41-83b7-673b691285b1">StreamFeedWithContinuationAndRetry(R)(Func(String, Task(FeedResponse(R))), EnumerationExceptionHandler, FeedResponseHandler, Nullable(Int32), Nullable(TimeSpan), ShouldRetry)</a></td><td>
This will execute a DocumentDB client FeedResponse method for you while handling retriable errors such as "too many requests". The caller must explicitly wrap the async call they want to make in a lambda. This is so that WithRetry can execute the lambda in order to ask for the task multiple times instead of getting an instance created at WithRetry method invocation time. Because of an implementation detail of the DocumentDb Client, you'll need your lambda to take the continuation token and apply it to the feed options passed into the method you've wrapped in your lambda. Example: "ExecuteResultWithRetry((continuation) => { feedOptions.RequestContinuation = continuation; YourCallHere(arguments, will, be, closured, feedOptions));"</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="24c431d1-89e1-cf98-a590-23fff2964474">StreamQueryWithContinuationAndRetry(TElement)</a></td><td>
This will execute a DocumentDB query in the form of an IQueryable (Linq form) and return the results. It handles paging, continuation tokens, and retriable errors such as "too many requests" for you, while streaming query results out in chunks via IEnumerable / yield. You don't need to use this if you have called InterceptQuery() on the IQueryable previously.</td></tr><tr><td>![Public method](media/pubmethod.gif "Public method")![Static member](media/static.gif "Static member")</td><td><a href="b9f76da0-e886-e26d-24b5-130bfc60d576">UnwrapAggregates</a></td><td>
A helper method that you may use in any custom retry logic to unwrap aggregate exceptions into a list of exceptions. This is safe to call on a non-aggregate and also handles aggregate aggregates.</td></tr></table>&nbsp;
<a href="#documentdbextensions-methods">Back to Top</a>

## See Also


#### Reference
<a href="2e7c24fb-f7c9-2314-1ff8-386e1be4f471">DocumentDbExtensions Class</a><br /><a href="856b2e23-9c8b-2618-f913-67d85d500616">Microsoft.Azure.Documents Namespace</a><br />