# Microsoft.Azure.Documents Namespace
 

\[Missing <summary> documentation for "N:Microsoft.Azure.Documents"\]


## Classes
&nbsp;<table><tr><th></th><th>Class</th><th>Description</th></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="c354736b-73fb-8d82-e8c1-9e8a7f104623">DateTimeDocumentDbJsonConverter</a></td><td>
ALL DateTime or DateTimeOffset properties in your DocumentDB document type class MUST be decorated with this attribute in order for the DateTime query expression translator to work properly. If your DateTime / DateTimeOffset properties are not formatted in DocumentDB identically to the format the expression translater generates, then the string comparisons will not work properly when executed on the DocumentDB server. Don't forget to use "new Date().toISOString()" which generates the same string format in your sprocs and triggers as well. -- This is actually pulled out of Newtonsoft.Json.dll via ILSpy and then slightly modified. -- The original has the ability to set "convert to universal time" and a custom format string, but DocumentDB doesn't allow access to this since we can only decorate properties with [JsonConvert(typeof(...))] and cannot pass in a properly configured instance of the converter. Thus, we wrote our own which is "already configured" to do what we want, so it doesn't matter if DocDB instantiates it. There is a feature request to make modifying serialization easier with DocDB that you can vote on here: https://feedback.azure.com/forums/263030-documentdb/suggestions/6422364-allow-me-to-set-jsonserializersettings</td></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="5170affb-a6da-2801-1bd3-714bc07d5356">DateTimeFormatExtensions</a></td><td>
Extensions to DateTime and DateTimeOffset. These extensions output ISO 8601 formatted strings in the same format as DocumentDB stored procedures, triggers, etc will get if they call (in JavaScript) "new Date().toISOString()"</td></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="c066f336-d70a-4bf9-3733-c3735dce01d4">DocumentDbConflictResponse</a></td><td>
This exception type will be thrown if the default ShouldRetry logic encounters a response that is expected but non-retriable such as Conflict or NotFound.</td></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="2e7c24fb-f7c9-2314-1ff8-386e1be4f471">DocumentDbExtensions</a></td><td>
Extensions for the DocumentDB Client which provide: * DocumentDB IQueryable interception / translation in order to allow use of DateTime/Offset types in where clauses. - Don't forget to mark all of your DateTime or DateTimeOffset properties with the DocumentDbDateTimeJsonConverter attribute! * Reliable execution with retries and automatic paging/streaming for DocumentDB IQueryables. * Reliable execution with retries for any DocumentDB Client method. * Both syncronous and asyncronous implementations of all methods.</td></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="a5a6f79a-af41-a26f-44e2-5ab6452f2a1d">DocumentDbNonRetriableResponse</a></td><td>
This exception type will be thrown if the default ShouldRetry logic encounters a response that is expected but non-retriable such as Conflict or NotFound.</td></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="5b11f591-7145-697d-1cc9-43830baefe48">DocumentDbRetriesExceeded</a></td><td>
This exception type will be thrown when the retry logic hits maxTime or maxRetries.</td></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="da3b714e-137a-7c1d-4b00-672763417f61">DocumentDbRetryHandlerError</a></td><td>
This exception type will be thrown if the ShouldRetry logic itself throws.</td></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="dbf0e6a5-e9b3-8c35-5299-a4644c6ee468">DocumentDbUnexpectedResponse</a></td><td>
This exception type will be thrown if the default ShouldRetry logic encounters a response it can't understand (should not happen).</td></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="5a3674e4-2b1a-2bad-ab7b-08208cdce377">DocumentsPage(T)</a></td><td /></tr><tr><td>![Public class](media/pubclass.gif "Public class")</td><td><a href="8c2e3a03-f1de-8b54-74c8-f5360d57c48e">PagingIQueryableExtensions</a></td><td /></tr></table>

## Interfaces
&nbsp;<table><tr><th></th><th>Interface</th><th>Description</th></tr><tr><td>![Public interface](media/pubinterface.gif "Public interface")</td><td><a href="cbcd444d-ffe1-6199-9c3a-29fa6b4f474e">IFeedResponse</a></td><td /></tr></table>

## Delegates
&nbsp;<table><tr><th></th><th>Delegate</th><th>Description</th></tr><tr><td>![Public delegate](media/pubdelegate.gif "Public delegate")</td><td><a href="98ab4230-aa0f-7803-7127-ba76e02bdce5">EnumerationExceptionHandler</a></td><td>
When intercepting a query, or using one of the reliable query execution methods, results are retrieved in "pages". It is sometimes not desirable to propagate exceptions back out to the caller who is enumerating results, if a failure happens on "get next page". For example if you pass an intercepted IQueryable back to OData and propagate an exception out, it will take down the entire w3wp.exe process :D So, by passing an implementation of this delegate you may ignore, log, or propagate the exception as you choose. If you return true, the exception will be re-thrown from its original context, and if you return false then a partial result set will be returned.</td></tr><tr><td>![Public delegate](media/pubdelegate.gif "Public delegate")</td><td><a href="4bfe406d-74ce-a904-0f38-461c2c8c2540">FeedResponseHandler</a></td><td>
When intercepting a query, or using one of the reliable query execution methods, results are retrieved in "pages". While all paging and enumeration is handled internally, you may wish to have access to certain interesting bits of information from each DocumentDB FeedResponse as it comes through "behind the scenes". Things like resource usage for example may be useful to log.</td></tr><tr><td>![Public delegate](media/pubdelegate.gif "Public delegate")</td><td><a href="fd8841db-a84c-d819-ba43-6a0f45838100">ShouldRetry</a></td><td>
If you wish to override the default retry logic, implement this prototype and pass it into the method call, or set DocumentDbExtensions.DefaultShouldRetryLogic You may wish to use this functionality, for example, if you have a sproc which is not "continuable" but instead throws a specific error that you can recognize as "entire transaction rolled back, please retry executing the entire call". In that case, your ShouldRetry logic can pick up on that and retry the call in its entirety. (Its recommended that your sprocs should instead return "how far they got" and be called a second time with those inputs removed in "continuation mode" course.) If your custom ShouldRetry logic can't understand the response, you should throw DocumentDbUnexpectedResponse. If your custom ShouldRetry logic can understand the response but it is not retriable, you should throw DocumentDbNonRetriableResponse or DocumentDbConflictResponse which is a special case of NonRetriable. If you throw any other exception type, that exception will be wrapped in DocumentDbRetryHandlerError.</td></tr></table>

## Enumerations
&nbsp;<table><tr><th></th><th>Enumeration</th><th>Description</th></tr><tr><td>![Public enumeration](media/pubenumeration.gif "Public enumeration")</td><td><a href="715754c4-da49-a7e9-8c04-2bf3ac982d7c">FeedResponseType</a></td><td>
FeedResponse callback type</td></tr></table>&nbsp;
